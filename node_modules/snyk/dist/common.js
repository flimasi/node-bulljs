"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isAnalyticsEnabled = exports.logError = exports.downloadExecutable = exports.runWrapper = exports.debugEnabled = exports.getCliArguments = exports.getCurrentConfiguration = exports.getCurrentSha256sum = exports.getCurrentVersion = exports.determineBinaryName = exports.WrapperConfiguration = exports.shasumFile = exports.versionFile = void 0;
const path = require("path");
const os = require("os");
const fs = require("fs");
const child_process_1 = require("child_process");
const https = require("https");
const crypto_1 = require("crypto");
const Sentry = require("@sentry/node");
exports.versionFile = path.join(__dirname, 'generated', 'version');
exports.shasumFile = path.join(__dirname, 'generated', 'sha256sums.txt');
class WrapperConfiguration {
    constructor(version, binaryName, expectedSha256sum) {
        this.version = version;
        this.binaryName = binaryName;
        this.expectedSha256sum = expectedSha256sum;
    }
    getVersion() {
        return this.version;
    }
    getBinaryName() {
        return this.binaryName;
    }
    getDownloadLocation() {
        const baseUrl = 'https://static.snyk.io/cli/v';
        return baseUrl + this.version + '/' + this.binaryName;
    }
    getLocalLocation() {
        const currentFolder = __dirname;
        return path.join(currentFolder, this.binaryName);
    }
    getShasumFile() {
        return this.expectedSha256sum;
    }
}
exports.WrapperConfiguration = WrapperConfiguration;
function determineBinaryName(platform, arch) {
    const basename = 'snyk-';
    let osname;
    let archname = '';
    let suffix = '';
    switch (platform) {
        case 'win32':
            osname = 'win';
            suffix = '.exe';
            break;
        case 'darwin':
            osname = 'macos';
            break;
        default: {
            let isAlpine = false;
            try {
                const result = child_process_1.spawnSync('cat /etc/os-release', { shell: true });
                isAlpine = result.stdout
                    .toString()
                    .toLowerCase()
                    .includes('id=alpine');
            }
            catch {
                isAlpine = false;
            }
            if (isAlpine) {
                osname = 'alpine';
            }
            else {
                osname = 'linux';
            }
            break;
        }
    }
    switch (arch) {
        case 'x64':
        case 'amd64':
            archname = '';
            break;
        case 'arm64':
            archname = '-arm64';
            break;
        default:
            throw '------------------------------- Warning -------------------------------\n' +
                ' The current platform (' +
                platform +
                ' ' +
                arch +
                ') is not supported by Snyk.\n' +
                ' You may want to consider using Docker to run Snyk, for details see: https://docs.snyk.io/snyk-cli/install-the-snyk-cli#snyk-cli-in-a-docker-image\n' +
                ' If you experience errors please reach out to support@snyk.io.\n' +
                '-----------------------------------------------------------------------';
    }
    if (platform == 'linux') {
        return basename + osname + archname + suffix;
    }
    else {
        return basename + osname + suffix;
    }
}
exports.determineBinaryName = determineBinaryName;
function getCurrentVersion(filename) {
    try {
        const version = fs.readFileSync(filename);
        return version.toString().trim();
    }
    catch {
        return '';
    }
}
exports.getCurrentVersion = getCurrentVersion;
function getCurrentSha256sum(binaryName, filename) {
    try {
        const allsums = fs.readFileSync(filename).toString();
        const re = new RegExp('^([a-zA-Z0-9]+)[\\s\\*]+' + binaryName + '$', 'mig');
        const result = re.exec(allsums);
        if (result) {
            return result[1];
        }
    }
    catch {
        //
    }
    return 'unknown-shasum-' + binaryName;
}
exports.getCurrentSha256sum = getCurrentSha256sum;
function getCurrentConfiguration() {
    const binaryName = determineBinaryName(os.platform(), os.arch());
    const version = getCurrentVersion(exports.versionFile);
    const expectedSha256sum = getCurrentSha256sum(binaryName, exports.shasumFile);
    return new WrapperConfiguration(version, binaryName, expectedSha256sum);
}
exports.getCurrentConfiguration = getCurrentConfiguration;
function getCliArguments(inputArgv) {
    const cliArguments = inputArgv.slice(2);
    return cliArguments;
}
exports.getCliArguments = getCliArguments;
function debugEnabled(cliArguments) {
    let debugIndex = cliArguments.indexOf('--debug');
    if (debugIndex < 0) {
        debugIndex = cliArguments.indexOf('-d');
    }
    return debugIndex >= 0;
}
exports.debugEnabled = debugEnabled;
function runWrapper(executable, cliArguments) {
    const debug = debugEnabled(cliArguments);
    if (debug) {
        console.debug('Executing: ' + executable + ' ' + cliArguments.join(' '));
    }
    const res = child_process_1.spawnSync(executable, cliArguments, {
        shell: false,
        stdio: 'inherit',
    });
    if (res.status !== null) {
        if (debug) {
            console.debug(res);
        }
        return res.status;
    }
    else {
        console.error(res);
        const spawnError = res.error;
        if ((spawnError === null || spawnError === void 0 ? void 0 : spawnError.code) == 'EACCES') {
            console.error("We don't have the permissions to install snyk. Please try the following options:\n" +
                '* If installing with increased privileges (eg sudo), try adding --unsafe-perm as a parameter to npm install\n' +
                '* If you run NPM <= 6, please upgrade to a later version.\n' +
                'If the problems persist please contact support@snyk.io and include the information provided above.');
        }
        else {
            console.error('Failed to spawn child process. (' + executable + ')');
        }
        return 2;
    }
}
exports.runWrapper = runWrapper;
function downloadExecutable(downloadUrl, filename, filenameShasum) {
    return new Promise(function (resolve) {
        const options = new URL(downloadUrl);
        const temp = path.join(__dirname, Date.now().toString());
        const fileStream = fs.createWriteStream(temp);
        const cleanupAfterError = (error) => {
            try {
                fs.unlinkSync(temp);
            }
            catch (e) {
                console.debug('Failed to cleanup temporary file (' + temp + '): ' + e);
            }
            resolve(error);
        };
        console.debug("Downloading from '" + downloadUrl + "' to '" + filename + "'");
        const req = https.request(options, (res) => {
            const shasum = crypto_1.createHash('sha256');
            res.pipe(fileStream);
            res.pipe(shasum);
            fileStream.on('finish', () => {
                fileStream.close();
                // compare shasums
                const actualShasum = shasum.digest('hex');
                const debugMessage = 'Shasums:\n- actual:   ' +
                    actualShasum +
                    '\n- expected: ' +
                    filenameShasum;
                if (filenameShasum && actualShasum != filenameShasum) {
                    cleanupAfterError(Error('Shasum comparison failed!\n' + debugMessage));
                }
                else {
                    console.debug(debugMessage);
                    // finally rename the file and change permissions
                    fs.renameSync(temp, filename);
                    fs.chmodSync(filename, 0o755);
                    console.debug('Downloaded successfull! ');
                    resolve(undefined);
                }
            });
        });
        req.on('error', (e) => {
            cleanupAfterError(e);
        });
        req.on('response', (incoming) => {
            if (incoming.statusCode &&
                !(200 <= incoming.statusCode && incoming.statusCode < 300)) {
                req.destroy();
                cleanupAfterError(Error('Download failed! Server Response: ' +
                    incoming.statusCode +
                    ' ' +
                    incoming.statusMessage));
            }
        });
        req.end();
    });
}
exports.downloadExecutable = downloadExecutable;
async function logError(context, err) {
    if (isAnalyticsEnabled()) {
        // init error reporting
        const version = getCurrentVersion(exports.versionFile);
        Sentry.init({
            dsn: 'https://3e845233db8c4f43b4c4b9245f1d7bd6@o30291.ingest.sentry.io/4504599528079360',
            release: version,
        });
        // report error
        const sentryError = new Error('[' + context + '] ' + err.message);
        sentryError.stack = err.stack;
        Sentry.captureException(sentryError);
        await Sentry.close();
    }
    // finally log the error to the console as well
    console.error(err);
}
exports.logError = logError;
function isAnalyticsEnabled() {
    if (process.env.snyk_disable_analytics == '1' ||
        process.env.SNYK_DISABLE_ANALYTICS == '1') {
        return false;
    }
    return true;
}
exports.isAnalyticsEnabled = isAnalyticsEnabled;
//# sourceMappingURL=common.js.map